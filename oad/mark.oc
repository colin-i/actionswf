
format elfobj64

override include_sec 1
include "common.h" "common.h.oh"

function mark_all(svu presprites,valueu end,valueu data)
	charx ok#1
	add end presprites
	while presprites!=end
		if presprites#!=(NULL) #here can have other tags, the map order is important when debugging
			set ok mark_presprite(presprites#,data)
			if ok!=(EXIT_SUCCESS)
				return (EXIT_FAILURE)
			end
		end
		incst presprites
	end
	return (EXIT_SUCCESS)
end
function mark_presprite(valueu ps,valueu data)
	charx ok#1
	valueu fr#1
	if ps#:presprite.apreframe!=(NULL)
		set fr ps#:presprite.apreframe
		set ok mark_branch(fr#:preframe.abranch,data)
		if ok=(EXIT_FAILURE)
			return (EXIT_FAILURE)
		end
	end
	svu frames;set frames ps#:presprite.preframes
	valueu fend#1;set fend frames
	add fend ps#:presprite.size
	while frames!=fend
		if frames#!=(NULL) #also with shows
			set fr frames#
			set ok mark_branch(fr#:preframe.abranch,data)
			if ok=(EXIT_FAILURE)
				return (EXIT_FAILURE)
			end
		end
		incst frames
	end
	return (EXIT_SUCCESS)
end
function mark_branch(valueu br,valueu data)
	charx ok#1;set ok mark_action(br#:branch.action_top,data)
	if ok=(EXIT_SUCCESS)
		svu ibrs;set ibrs br#:branch.innerbranches
		valueu end#1;set end ibrs
		add end br#:branch.isize
		while ibrs!=end
			set ok mark_branch(ibrs#,data)
			if ok=(EXIT_FAILURE)
				return (EXIT_FAILURE)
			end
			incst ibrs
		end
		if br#:branch.subbranch!=(NULL)
			set ok mark_branch(br#:branch.subbranch,data)
			if ok=(EXIT_FAILURE)
				return (EXIT_FAILURE)
			end
		end
		return (EXIT_SUCCESS)
	end
	return (EXIT_FAILURE)
end
importx "realloc" realloc
function mark_action(valueu act,valueu data)
	if act!=(NULL) #can be trick branch, while(true){break}
		valueu size#1;set size data#:oadata.size
		valueu ix#1;set ix size
		valueu index#1;set index ix
		add size \mark\
		svu marks;set marks realloc(data#:oadata.marks,size)
		if marks!=(NULL)
			set data#:oadata.marks marks
			set data#:oadata.size size
			div index \mark\
			set act#:action.amark index

			add ix marks
			if ix=marks
				set ix#:mark.prev (mark_nothing)
				set ix#:mark.next (mark_nothing)
			else
				set ix#:mark.next (mark_nothing)
				div size \mark\
				dec size
				set ix#:mark.prev size
				dec ix#:mark.prev

				sub ix \mark\
				set ix#:mark.next size
			end

			return (EXIT_SUCCESS)
		end
		return (EXIT_FAILURE)
	end
	return (EXIT_SUCCESS)
end

function mark_compare(valueu prevoadata,svu presprites,dataxu size,valueu data)
	svu prevpresprites#1;set prevpresprites prevoadata#:preoadata.presprites
	valueu prevend#1;set prevend prevpresprites;add prevend prevoadata#:preoadata.size
	valueu end#1;set end presprites
	add end size
	while presprites!=end
		if presprites#!=(NULL) #from parsed where the map to oadata out was
			charx ok#1
			valueu pvps#1
			if prevpresprites!=prevend
				set pvps prevpresprites#
				incst prevpresprites
#!
				valueu ps#1;set ps presprites#
				valueu fr#1
				if ps#:presprite.apreframe!=(NULL)
					set fr ps#:presprite.apreframe
					#call mark_compare_branch(fr#:preframe.abranch
				end
				svu frs;set frs ps#:presprite.preframes
				valueu fend#1;set fend frs
				add fend ps#:presprite.size
				while frs!=fend
					if frs#!=(NULL) #shows
						set fr frs#
						#call mark_compare_branch(fr#:preframe.abranch
					end
					incst frs
				end
!
			else
				set ok mark_presprite(presprites#,data)
				if ok!=(EXIT_SUCCESS)
					return (EXIT_FAILURE)
				end
			end
		end
		incst presprites
	end
	return (EXIT_SUCCESS)
end
