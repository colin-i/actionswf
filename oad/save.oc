
format elfobj64

override include_sec 1
include "common.h" "common.h.oh"

const BYTE=1
const WORD=2
const DWORD=4

import "global_presprites_size" global_presprites_size
function save(svu presprites,valueu file)
	valueu end#1;set end presprites
	add end global_presprites_size()
	wordxu counted#1;set counted 0
	sv pointer#1;set pointer presprites
	while pointer!=end
		if pointer#!=(NULL)
			inc counted
		end
		incst pointer
	end
	charx out#1;set out swrite(counted,file)
	if out!=0
		while presprites!=end
			valueu ps#1;set ps presprites#
			if ps!=(NULL)
				if ps#:presprite.apreframe!=(NULL)
					set out truewrite(file)
					if out=0
						return (EXIT_FAILURE)
					end
					set out save_frame(ps#:presprite.apreframe,file)
				else
					set out falsewrite(file)
				end
				if out=0
					return (EXIT_FAILURE)
				end
				dataxu size#1;set size ps#:presprite.size
				sub size : #1 is always only ready for next
				valueu fend#1;set fend size
				div size :
				set out swrite(size,file) #store from_show places, next they can be with action and later one frame is unmodified, plus all gotoAnd places
				if out!=0
					svu frames#1;set frames ps#:presprite.preframes
					add fend frames
					while frames!=fend
						if frames#!=(NULL)
							set out truewrite(file)
							if out=0
								return (EXIT_FAILURE)
							end
							set out save_frame(frames#,file)
						else  # from_show
							set out falsewrite(file)
						end
						if out=0
							return (EXIT_FAILURE)
						end
						incst frames
					end
				end
			end
			incst presprites
		end
		return (EXIT_SUCCESS)
	end
	return (EXIT_FAILURE)
end

importx "fwrite" fwrite

function lowwrite(valueu buf,charx sz,valueu file)
	charx out#1;set out fwrite(buf,sz,1,file)
	return out
end
function mediumwrite(valueu buf,wordxu sz,valueu file)
	charx out#1;set out fwrite(buf,sz,1,file)
	return out
end
function highwrite(valueu buf,dataxu sz,valueu file)
	charx out#1;set out fwrite(buf,sz,1,file)
	return out
end
function swrite(wordxu n,valueu file)
	charx out#1;set out lowwrite(#n,(WORD),file) #size_t but WORD write
	return out
end
function iwrite(dataxu n,valueu file)
	charx out#1;set out lowwrite(#n,(DWORD),file)
	return out
end
function truewrite(valueu file)
	char a=TRUE
	charx out#1;set out lowwrite(#a,(BYTE),file)
	return out
end
function falsewrite(valueu file)
	char a=FALSE
	charx out#1;set out lowwrite(#a,(BYTE),file)
	return out
end

importx "strlen" strlen

function save_strings(valuexu pointer,valueu end,valueu file)
	valuexu strings#1;set strings pointer
	wordxu size#1;set size 0  #string was in constantpool that is actionrecordheader with ui16 size
	add end pointer
	valueu str#1;valueu text#1
	while pointer!=end
		set str pointer#
		set text str#:string.base
		add text str#:string.off
		add size strlen(text)
		inc size ##null end \0
		incst pointer
	end
	charx out#1;set out swrite(size,file)
	if out!=0
		while strings!=end
			set str strings#
			set text str#:string.base
			add text str#:string.off
			set size strlen(text)
			inc size ##null
			set out mediumwrite(text,size,file)
			if out=0
				return 0
			end
			incst strings
		end
	end
	return out
end

function save_frame(valueu aframe,valueu file)
	charx out#1;set out save_strings(aframe#:preframe.ustrings,aframe#:preframe.ussize,file)
	if out!=0
		set out save_strings(aframe#:preframe.strings,aframe#:preframe.ssize,file)
		if out!=0
			set out save_branch(aframe#:preframe.abranch,file)
		end
	end
	return out
end

function save_branch(valueu br,valueu file) #at least a mathend/function_marker/whileblock_end/if_marker here
	# branch_log. here we are gipsying because on 32 we are not agreeing with qword size. we are writing cuts sized parts
	#with this occasion: it is good that multiple action calls are not merged into a branch
	valueu cuts#1;set cuts br#:branch.cuts
	valueu end#1;set end cuts
	add end br#:branch.size
	charx out#1;dataxu sz#1
	while cuts!=end
		set sz cuts#:branchcut.size
		set out iwrite(sz,file)
		if out=0
			return 0
		end
		valueu code#1;set code cuts#:branchcut.x
		set out highwrite(code,sz,file)
		if out=0
			return 0
		end
		add cuts \branchcut\
	end
	set out iwrite(0,file)
	if out!=0
		set sz br#:branch.isize ##expanded size
		set out iwrite(sz,file)
		if out!=0
			svu pointer;set pointer br#:branch.innerbranches
			set end pointer
			add end sz
			while pointer!=end
				set out save_branch(pointer#,file)
				if out=0
					return 0
				end
				incst pointer
			end

			set pointer br#:branch.subbranch
			if pointer!=(NULL)
				set out truewrite(file)
				if out!=0
					set out save_branch(pointer,file)
				end
			else
				set out falsewrite(file)
			end
		end
	end
	return out
end
