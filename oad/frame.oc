
format elfobj64

importx "realloc" realloc

override include_sec 1
include "common.h" "common.h.oh"

function re_alloc(sv pmem,dataxu size) #only dataxu external sizes, and +1 increments
	dataxu currentmaxsize#1;set currentmaxsize size
	divu currentmaxsize ((sprites_realloc_onepart))
	mult currentmaxsize ((sprites_realloc_onepart))
	if size=currentmaxsize   ##is not on the edge
		add currentmaxsize ((sprites_realloc_onepart))
		sv newmem;set newmem realloc(pmem#,currentmaxsize)
		if newmem!=(NULL)
			set pmem# newmem
			return (EXIT_SUCCESS)
		end
		return (EXIT_FAILURE)
	end
	return (EXIT_SUCCESS)
end
function re_calloc(sv pmem,svu size,valueu newsize)
	charx ok#1;set ok re_alloc(pmem,size)
	if ok=(EXIT_SUCCESS)
		add size pmem#
		add newsize pmem#
		while size!=newsize
			set size# (NULL)
			add size :
		end
	end
	return ok
end
function re_calloc_size(sv pmem,sdu psize,dataxu newsize)
	charx ok#1;set ok re_calloc(pmem,psize#,newsize)
	if ok=(EXIT_SUCCESS)
		set psize# newsize
	end
	return ok
end

importx "malloc" malloc
importx "free" free

function preframe_init()
	sv pf;set pf malloc((\preframe\))
	if pf!=(NULL)
		valueu bra#1
		set bra malloc((\branch\))
		if bra!=(NULL)
			sv strings
			set strings malloc((sprites_realloc_onepart))
			if strings!=(NULL)
				sv ustrings
				set ustrings malloc((sprites_realloc_onepart))
				if ustrings!=(NULL)
					set pf#:preframe.abranch bra
					set pf#:preframe.strings strings
					set pf#:preframe.size 0
					set pf#:preframe.ustrings ustrings
					set pf#:preframe.usize 0
					return pf
				end
				call free(strings)
			end
			call free(bra)
		end
		call free(pf)
	end
	return (NULL)
end
function preframe_free(sv pf,charx log,charx ainit)
	if log=(TRUE)
		call frame_print_top(ainit)
	end
	call free(pf#:preframe.abranch)

	sv strings;set strings pf#:preframe.strings
	sv s;set s strings
	sv end;set end pf#:preframe.size
	add end s
	while s!=end
		call free(s#)
		incst s
	end
	call free(strings)

	#is a different free than strings, will have one branch vs multiple
	sv ustrings;set ustrings pf#:preframe.ustrings
	set s ustrings
	set end pf#:preframe.usize
	add end s
	while s!=end
		call free(s#)
		incst s
	end
	call free(ustrings)

	call free(pf)
end

import "print" print
import "print_indent" print_indent
import "print_unindent" print_unindent

function frame_init(valueu total)
	sv f;set f malloc((\frame\))
	if f!=(NULL)
		valueu size#1;set size (\line\)
		mult size (\line\)
		sv lines;set lines malloc(size)
		if lines!=(NULL)
			set f#:frame.lines lines
			set f#:frame.total total
			return f
		end
		call free(f)
	end
	return (NULL)
end
function frame_free(sv f,valueu pointer_is_log,charx ainit)
	sv lines;set lines f#:frame.lines
	sv pointer;set pointer lines
	valueu end#1;set end f#:frame.total
	if pointer_is_log!=(NULL)
		call frame_print_top(ainit)
		call print_indent()
		call print("lines=%lu",end)
		call print_unindent()
	end
	mult end (\line\)
	add end pointer
	while pointer!=end
		add pointer (\line\)
	end
	call free(lines)
	call free(f)
end

function frame_print_top(charx ainit)
	if ainit=(xlog_ainit_false)
		call print("frame")
	else
		call print("init")
	end
end

function nframe_init(sv pf,valueu total)
	set pf# preframe_init()
	if pf#!=(NULL)
		valueu f#1;set f frame_init(total)
		return f
	end
	return (NULL)
end

function get_preframe(sv presprites,wordxu preid,charx ainit)
	sv ps=:
	mult ps preid
	add ps presprites
	set ps ps#
	if ainit=(xlog_ainit_false)
		sv pf
		set pf ps#:presprite.preframes
		add pf ps#:presprite.size
		decst pf
		return pf#
	end
	return ps#:presprite.apreframe
end
