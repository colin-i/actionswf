Format ElfObj64

include "../include/prog.h"

#win32 with _
importx "strlen" strlen
importx "memcmp" memcmp

function actionpoolid_root()
    data id#1
    return #id
endfunction
function actionpoolid()
    data id#1
    return #id
endfunction
function actionpoolid_get()
    sd p_id
    setcall p_id actionpoolid()
    return p_id#
endfunction

import "struct_ids_actionpool" struct_ids_actionpool
#block
function actionpool_currentblock()
    sd poolid;sd block
    setcall poolid actionpoolid_get()
    setcall block struct_ids_actionpool((ids_get),poolid)
    return block
endfunction

import "f_close" f_close
import "mem_free" mem_free

function pool()
	value file=NULL
	value mem=NULL
	charx constants#maxuint16
	vstrx cursor#1
	valuex end#1
	if file!=(NULL)
		call f_close(#file)
	elseif mem!=(NULL)
		call mem_free(#mem)
	end
end
const constpool_unique=0x00
const  constpool_multi=0xff
function pool_entry()
	set pool.cursor# (constpool_unique)
	inc pool.cursor
end
function pool_realentry(sd pos)
	ss p;set p #pool.constants
	add p pos
	set p# (constpool_multi)
end
function pool_reentry()
	if pool.cursor<^pool.end
		sd type;set type pool.cursor#
		inc pool.cursor
		if type=(constpool_unique)
			return (not_an_id)
		end
		return (any_id)
	end
	call error("error at pool read")
end

importx "sprintf" sprintf
importx "access" access
importx "fseek" fseek
importx "fread" fread
importx "fclose" fclose
importx "unlink" unlink

import "block_get_mem" block_get_mem
import "block_get_size" block_get_size
import "stack_to_word_arg" stack_to_word_arg
import "word_arg_to_stack" word_arg_to_stack
import "swf_mem" swf_mem

#aftercallimport ebool

import "f_open_mem" f_open_mem
import "f_open" f_open
import "memalloc" memalloc
import "f_tell_errors" f_tell_errors
import "memalloc_errors" memalloc_errors

function pool_init(sd flags,sd path)
	and flags (flags_pool)
	if flags!=0
		sd s;setcall s strlen(path)
		sd a=1+4+1
		add a s
		sd p;set p memalloc(a)
		call sprintf(p,"%s.pool",path)
		datax int#1
		set int access(p,(F_OK))
		if int=-1
			set pool.file f_open_mem(p,"wb")
			set pool.cursor #pool.constants
		else
			sd file;set file f_open(p,"rb")
			call fseek(file,0,(SEEK_END))
			set pool.end f_tell_errors(file)
			call fseek(file,0,(SEEK_SET))
			set pool.mem memalloc_errors(pool.end,file)
			call fread(pool.mem,pool.end,1,file)
			call fclose(file)
			and flags (flag_pool_del)
			if flags!=0
				call unlink(p) #can also go on success (extra code there), but here is optimization rerun, normally no errors
			end
			set pool.cursor pool.mem
			#end for error checks?
			add pool.end pool.cursor
		end
	end
end
function pool_done()
	if pool.file!=(NULL)
		if pool.cursor!=#pool.constants
			import "f_write" f_write
			sub pool.cursor #pool.constants
			call f_write(pool.file,#pool.constants,pool.cursor)
			set pool.cursor #pool.constants
		end
	end
end

#pool id (U16)
function actionpool_value(ss value)
	sd id
	set id actionpool_value_ex(value,(FALSE))
	return id
end
#pool id
function actionpool_value_ex(ss value,sd force)
    sd poolid
    setcall poolid actionpoolid_get()
    sd nr
    call swf_mem((mem_exp_change_pool),poolid)
    setcall nr actionpool_getvalue_ex(value,force)
    call swf_mem((mem_exp_change_back_pool))
    return nr
endfunction
#pool id
#function actionpool_getvalue(ss value);	sd id;	set id actionpool_getvalue_ex(value,(FALSE));	return id;end
import "swf_mem_add" swf_mem_add
import "error" error
#pool id
function actionpool_getvalue_ex(ss value,sd force)
	sd block
	setcall block actionpool_currentblock()
	sd size
	setcall size block_get_size(block)
	sd nr
	sd newlen
	setcall newlen strlen(value)
	if size=0
	#is first value, add the pools header and count=1 , # before: actionpool_getvalue(the pool mem is already selected when it comes from the second  at push)
		if force=(FALSE)
			if pool.file!=(NULL)
				call pool_entry()
			elseif pool.mem!=(NULL)
				set nr pool_reentry()
				if nr=(not_an_id)
					return (not_an_id)
				end
			end
		end
		sd onevalue=1
		call swf_mem_add(#onevalue,2)
		set nr 0
	else
		sd mem
		sd count
		setcall mem block_get_mem(block)
		setcall count word_arg_to_stack(mem)
		set nr count
		if force=(FALSE)
			add mem (WORD)
			while count!=0
				sd len
				setcall len strlen(mem)
				if len=newlen
					sd comp
					setcall comp memcmp(mem,value,len)
					if comp=0
						sub nr count
						if pool.file!=(NULL)
							call pool_realentry(nr)
						end
						return nr
					endif
				endif
				inc len
				add mem len
				dec count
			endwhile
			if pool.file!=(NULL)
				call pool_entry()
			elseif pool.mem!=(NULL)
				sd testid
				set testid pool_reentry()
				if testid=(not_an_id)
					return (not_an_id)
				end
			end
			setcall mem block_get_mem(block)
		end
		if nr=(maxuint16)
			call error("max uint16 at action pool") #Count  UI16  Number of constants to follow
		end
		set count nr
		inc count
		call stack_to_word_arg(count,mem)
	endelse
	inc newlen
	call swf_mem_add(value,newlen)
	return nr
endfunction
