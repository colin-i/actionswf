
format elfobj64

include "../include/prog.h"

import "f_close" f_close

function x_data()
	value f=NULL
	datax size#1
	if f!=(NULL)
		call f_close(#f)
	end
end

function debug_x_pointer(sd value,sv pointer)
	if x_data.f!=(NULL)
		import "action_debug" action_debug
		sub value action_debug((action_debug_get_mem))
		inc value  ##only to not be comparable with (no_pointer)
		set pointer# value
	end
end

import "action_code_values" action_code_values
import "action_code_get" action_code_get

importx "fwrite" fwrite
importx "strlen" strlen
importx "sprintf" sprintf
importx "fseek" fseek


aftercallimport ebool

import "error" error
import "memalloc" memalloc
import "f_open_mem" f_open_mem
import "f_tell" f_tell
import "f_write" f_write

function x_init(datax flag,sd path)
	if x_data.f!=(NULL)
		call error("swf started, x not closed")
	end
	#set flag flags
	and flag (flags_x)
	if flag!=0
		sd s;setcall s strlen(path)
		sd a=2+1
		add a s
		sd b;setcall b memalloc(a)
		call sprintf(b,"%s.x",path)

		#sd x=flag_x
		#and x flag
		#if x=0 #save
			set x_data.f f_open_mem(b,"wb") #'b' on windows is not 't' that can change line ends and is working more there
			and flag (debug_x_pad)
		#else #restore
			#set x_data.f f_open_mem(b,"rb")
			#and log is on current x, here is another x, no log, no parse
			#and flags (~debug_log)
		#end
	end
	#return flags
end

function debug_x_pointers(valuex start,valuex size)
	valuex mark#1
	if x_data.f!=(NULL)
		set x_data.size 0

		inc size  ##is on last \0
		sub size start
		if x_init.flag=(debug_x_pad)
			set mark f_tell(x_data.f) #long
			add mark :
			add mark size    ##overflow is same

			sd pad=0xf
			xor pad mark
			inc pad
			and pad 0xf
			sd all;set all size; add all pad
			call f_write(x_data.f,#all,:)
		else
			call f_write(x_data.f,#size,:)
		end
		set mark f_tell(x_data.f)
		call f_write(x_data.f,start,size)  #write now? is not ready ..str\0.. . the system will write something anyway and if error is good for visual debug, and fseek needs an extra check with this size that can have 0x10000 one string * multiple pointers
		if x_init.flag=(debug_x_pad)
			if pad!=0
				char zero={0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0}
				call f_write(x_data.f,#zero,pad)
			end
		end
	end
end

function debug_x_base(sd mem,sd size)
	#already wrote
	sub size x_data.size
	add mem x_data.size

	call f_write(x_data.f,mem,size)
	add x_data.size size
end
function debug_x(sd mem,sd nr)
	if x_data.f!=(NULL)
		mult nr (action_code_values_unit)
		call debug_x_base(mem,nr)

		call fseek(x_data.f,debug_x_pointers.mark,(SEEK_SET))
		call fwrite(debug_x_pointers.start,debug_x_pointers.size,1,x_data.f)
		call fseek(x_data.f,0,(SEEK_END))
	end
end

function debug_x_preexpand(sv p_codepointer)
	sv codepointer;set codepointer p_codepointer#
	sd value;set value codepointer#
	if x_data.f!=(NULL)
		if value!=(no_pointer)
			sd values;set values action_code_values()
			sub codepointer values
			call debug_x_base(values,codepointer)
			incst x_data.size  ##the string will be expanded and written
		end
	end
	incst p_codepointer#
	return value
end
function debug_x_expand(sd values)
	if x_data.f!=(NULL)
		sd size;set size action_code_get()
		sub size values
		call f_write(x_data.f,values,size)
	end
end
