
format elfobj64

#ActionPush added to a query, and released at the action for them

include "../include/prog.h"

import "mem_free" mem_free

function push()
	value mem=NULL
	datax size#1    #same as debug_data, and here is from x values
	datax allsize#1
	if mem!=(NULL)
		call mem_free(#mem)
	end
end

importx "memcpy" memcpy

#aftercalli

import "actionrecordheader_core" actionrecordheader_core
import "swf_actionblock_add" swf_actionblock_add

function actionpush()
#allmost all before action_one, but also before actionrecordheader( two examples: a=function (){} and a=1?2:3 )
	if push.size!=0
		call actionrecordheader_core((ActionPush),push.size)
		call swf_actionblock_add(push.mem,push.size)
		import "debug_phase_code_add" debug_phase_code_add
		call debug_phase_code_add((TRUE),#push.size)
		set push.size 0
	end
end

import "actionpool_value" actionpool_value

import "memalloc" memalloc
import "memrealloc" memrealloc
import "error" error

function push_init()
	set push.allsize 1
	set push.mem memalloc(1) #same
	set push.size 0
end
function push_add(sd size,sd value)
	sd newsize
	set newsize push.size
	add newsize size
	if newsize>^(lastword)
		call error("actionrecordheader too big")
	end
	if newsize>^push.allsize
		set push.allsize newsize
		add push.allsize 0x100
		set push.mem memrealloc(push.mem,push.allsize)
	end
	sd mem;set mem push.mem
	add mem push.size
	call memcpy(mem,#value,size)
	set push.size newsize
end

function action_push(sd type,sd valuel,sd valueh)
	if type=(ap_Constant8)
		#set the action pool(if isn't) and verify to add +1size if 8 will go to ap_Constant16
		sd translated_id
		setcall translated_id actionpool_value(valuel)
		if translated_id<=0xff
			call push_add((BYTE),(ap_Constant8))
			call push_add((BYTE),translated_id)
		else
			call push_add((BYTE),(ap_Constant16))
			call push_add((WORD),translated_id)
		end
	elseif type=(ap_Integer)
		call push_add((BYTE),(ap_Integer))
		call push_add((DWORD),valuel)
	elseif type=(ap_Boolean)
		call push_add((BYTE),(ap_Boolean))
		call push_add((BYTE),valuel)
	elseif type=(ap_Null)
		call push_add((BYTE),(ap_Null))
	elseif type=(ap_Undefined)
		call push_add((BYTE),(ap_Undefined))
	elseif type=(ap_RegisterNumber)
		call push_add((BYTE),(ap_RegisterNumber))
		call push_add((BYTE),valuel)
	else #if type=(ap_double)
		call push_add((BYTE),(ap_double))
		call push_add((DWORD),valuel)
		call push_add((DWORD),valueh)
	end # string literal, float
endfunction

#! plan for float
function float(sd h,sd l)
const sign   =0x80000000
	sd sign=sign
	and sign h
	and h  ~sign
const max_exp=0x7fF00000
	sd exp =max_exp
	and exp h
	and h  ~max_exp
	if exp=0
		if h=0
			if l=0
				+-0
				return (TRUE)
			end
		end
		#subnormal always dif, at 32 [1/2^149,1/2^126), at 64 [1/2^1074,1/2^1022)
		return (FALSE)
	end
	if exp=(max_exp)
		if h=0
			if l=0
				+-inf
				return (TRUE)
			end
		end
		(s/q/alt/+)Nan
		return (FALSE)
	end
#at 32 -126 to 127, at 64 -1022 to 1023
#                  12345678
const to_max_exp=0x  100000
const e64=1023
const e32=127
const minexp=e64-e32-1 # 897
const maxexp=e64+e32   # 1150
const minexp_opt=minexp*to_max_exp
const maxexp_opt=maxexp*to_max_exp
	if exp<(minexp_opt)
		return (FALSE)
	end
	if exp>(maxexp_opt)
		return (FALSE)
	end
const f2    =0xE0000000
const f2to32=0x20000000
	sd f2=~f2
	and f2 l
	if f2!=0
		return (FALSE)
	end
	divu l (f2to32)

const e64to32=(minexp-1)*to_max_exp
	sub exp (e64to32)
	mult exp 8   #to 32 exp bits
	mult h 8     #same

	or h exp
	or h sign
	or h l
	return (TRUE)
end
