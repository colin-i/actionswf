
format elfobj64

include "../include/prog.h"

function debug_mark()
	valuex row#1
	return #row
endfunction
function debug_mark_start()
	sv a;setcall a debug_mark()
	set a# 0
endfunction
function debug_mark_add()
	sv a;setcall a debug_mark()
	add a# :
endfunction
function debug_mark_get()
	value offsets=NULL
	const p_offsets^offsets

	sv a;setcall a debug_mark()
	sv b;set b a#
	add b offsets
	return b
endfunction

function debug_target()
	valuex a#1
	return #a
endfunction

function debug_end()
	valuex a#1
	return #a
endfunction
function debug_actions()
	#now is a string #datax a#1  #65535
	value mem=NULL
	#mem_struct_size said is 8 first 4 all_size, and after mem_struct__size_off is the size and for ,00(3 bytes here) there tag+len 1+2 same 3 bytes there
	#but all_size is growing +0x1000 from that limit, and the error is catched there, valuex?
	#there is a limit on actions and on constant pool, so don't worry here
	datax size#1
	datax all_size#1
endfunction

import "mem_free" mem_free
import "f_close" f_close

function debug_free()
	sv of%p_offsets
	if of#!=(NULL)
		call mem_free(of)
		value file=NULL
		const p_debug_file^file
		call f_close(#file)
		call mem_free(#debug_actions.mem)
	endif
endfunction

function debug_phase_init(ss pointer)
	sv of%p_offsets
	if of#!=(NULL)
		sv a;setcall a debug_mark_get()
		set a# pointer
		call debug_mark_add()
	endif
endfunction
function debug_phase_parse(ss pointer)
	sv of%p_offsets
	if of#!=(NULL)
		sv a
		sv start;setcall start debug_mark_get()
		sv target;setcall target debug_target()
		if target#=(NULL)
		#need to know empty rows
			set a start
			while pointer>a#
				incst a
			endwhile
			set target# a
		else
			set a target#
		endelse
		#if pointer>=^a#  # and > ? it's not with spaces at end, therefore ";   \nabc" can go wrong
		if pointer<^a#
			ret
		endif
		import "action_code_get" action_code_get   #the pointer is not reallocated, can use offset but will be slower
		sd x;setcall x action_code_get()
		while start#<^pointer   #or a
			set start# x
			call debug_mark_add()
			setcall start debug_mark_get()
		endwhile
		set start# x      ##also,set for this row, can be the only set
		call debug_mark_add()
		set target# (NULL)
	endif
endfunction

function debug_action_phase()
	sv of%p_offsets
	if of#!=(NULL)
		call debug_mark_start()  #second and third iteration
	endif
endfunction

import "row_termination" row_termination

importx "strlen" strlen
importx "sprintf" sprintf



aftercallimport ebool

import "memalloc" memalloc
import "f_open_mem" f_open_mem
import "alt_init" alt_init

function debug_init(sd flags,sd path)
	sv of%p_offsets
	if flags!=(debug_none)
		setcall of# memalloc(1)  #0 on some systems can be NULL return

		sd s;setcall s strlen(path)
		sd a=5;add a s
		sd b;setcall b memalloc(a)
		call sprintf(b,"%s.log",path)
		sv file%p_debug_file
		setcall file# f_open_mem(b,"wb")

		setcall debug_actions.mem memalloc(1)
		#this is later #set debug_actions.size 0
		set debug_actions.all_size 1
	endif
	call alt_init(flags,path,s) #is here because need to set a default value inside
endfunction

import "f_printf" f_printf
import "f_write" f_write

function debug_action_init(ss ac)
	sv of%p_offsets
	if of#!=(NULL)
		sd start;set start ac

		sd row=1     #at least one row, example: row 1,3 actions
		while ac#!=0
			call row_termination(#ac,#row)
			inc ac
		endwhile

		#out rows\nac\n
		sv file%p_debug_file
		char f={Percent,l,u,LineFeed,Percent,s,LineFeed,Nullchar}
		call f_printf((fprintf_min+2),file#,#f,row,start)

		mult row :
		import "memrealloc" memrealloc
		setcall of# memrealloc(of#,row)

		call debug_mark_start()  #prepare for first iteration

		#set target to 0, for recognizing blank rows at second iteration
		sv target;setcall target debug_target()
		set target# (NULL)

		add row of#
		sv end;setcall end debug_end()   #at third iteration
		set end# row

		set debug_actions.size 0
	endif
endfunction

function debug_phase_code(sd codepointer)
	sv of%p_offsets
	if of#!=(NULL)
		sv a;setcall a debug_mark_get()
		if codepointer=a#   #can also be smaller
			sv b;set b a
			sv end;setcall end debug_end()
			while codepointer=b#
				call debug_mark_add()
				setcall b debug_mark_get()
				if b=end#
					break
				endif
			endwhile
			sub b a
			div b :

			#out rows,[action1,action2]\n   #is not reaching here at "     " at no actions
			sv file%p_debug_file
			call f_printf((fprintf_min+1),file#,"%lu",b)
			call f_write(file#,debug_actions.mem,debug_actions.size)
			call f_write(file#,"\n",1)
			set debug_actions.size 0
		endif
	endif
endfunction

function debug_base_core(sd id)
	sv file%p_debug_file
	call f_printf((fprintf_min+1),file#,"%u\n",id) #swf_button is calling action_sprite
end
function debug_base(sd id)
	sv of%p_offsets
	if of#!=(NULL)
		call debug_base_core(id)
	end
end
function debug_show(sd id)
	sv of%p_offsets
	if of#!=(NULL)
		call debug_base_core(id)
		call debug_write("\n\n",2)
	end
end
function debug_write(ss s,sd d)
	sv file%p_debug_file
	call f_write(file#,s,d)
end
function debug_spritedone(sd p,sd i)
	sv of%p_offsets
	if of#!=(NULL)
		call debug_base_core(p)
		call debug_write("\n",1)
		call debug_base_core(i)
	end
end

function debug_phase_code_add(sd is_long,sd size)
	sv of%p_offsets
	if of#!=(NULL)
		sd sz;set sz debug_actions.size
		if is_long=(TRUE)
			add sz 3
		else
			add sz 1
		end
		if sz>^debug_actions.all_size
			set debug_actions.all_size sz
			add debug_actions.all_size 0x1000
			set debug_actions.mem memrealloc(debug_actions.mem,debug_actions.all_size)
		end
		ss m;set m debug_actions.mem
		add m debug_actions.size

		set m# (Comma) #even if is only 1 action is lines,a1,a2...an

		if is_long=(TRUE)
			char b#1
			char b2#1+1
			call sprintf(#b,"%2X",size)
			if b!=(Space)
				inc m;set m# b
			else
				dec sz
			end
			inc m;set m# b2
		end
		set debug_actions.size sz
	endif
endfunction
